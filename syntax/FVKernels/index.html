<!DOCTYPE html><head><meta charset="UTF-8"><title>FVKernels System | Chamois</title><link rel="icon" type="image/x-icon" href="../../media/chamois_logo.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Chamois</a><a href="https://github.com/matthiasneuner/chamois" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="../../getting_started.html">Getting Started</a></li><li><a href="../../singularity.html">Singularity container</a></li><li><a href="../../publications.html">Publications</a></li><li><a href="../../contributors.html">Contributors</a></li><li><a href="#!" class="dropdown-trigger" data-target="cc812de0-9945-4a61-8bcb-7f120ed3c569" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li></ul><a href="#" class="sidenav-trigger" data-target="9a745332-c572-4a93-ad83-44b4e1020d3e"><i class="material-icons">menu</i></a><ul class="sidenav" id="9a745332-c572-4a93-ad83-44b4e1020d3e"><li><a href="../../getting_started.html">Getting Started</a></li><li><a href="../../singularity.html">Singularity container</a></li><li><a href="../../publications.html">Publications</a></li><li><a href="../../contributors.html">Contributors</a></li><li><a href="#!" class="dropdown-trigger" data-target="289f3efd-fc4d-4230-826f-dd35989ecbb2" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="cc812de0-9945-4a61-8bcb-7f120ed3c569"><li><a href="../chamois.html">Chamois syntax</a></li></ul><ul class="dropdown-content" id="289f3efd-fc4d-4230-826f-dd35989ecbb2"><li><a href="../chamois.html">Chamois syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="f7611a06-030a-4e07-b46f-08d1db8825ec" data-section-level="1" data-section-text="FVKernels System"><h1 id="fvkernels-system">FVKernels System</h1><p>For an overview of MOOSE FV please see <a href="../../finite_volumes/fv_design.html">Finite Volume Design Decisions in MOOSE</a>.</p><p>For the finite volume method (FVM), <code>FVKernels</code> are the base class for <code>FVFluxKernel</code>, <code>FVElementalKernel</code>. These specialized objects satisfy the following tasks:</p><p>* <code>FVFluxKernel</code> represents numerical fluxes evaluate on the element faces.   These terms originate from applying Gauss&#x27; divergence theorem.</p><p>* <code>FVElementalKernel</code> represents terms that do not contain a spatial   derivative so that Gauss&#x27; theorem cannot be applied. These terms include   time derivatives, externally imposed source terms, and reaction terms.</p><p>Note: Currently, the <code>FVElementalKernel</code> category only contains kernels (subclasses) representing time derivatives. Kernels representing externally imposed sources or reaction terms will be added in the near future.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p>In the documentation that follows, we will use &#x27;-&#x27; and &#x27;<strong>&#x27; to represent different sides of a face. This is purely notation. In the MOOSE code base, the &#x27;-&#x27; side is represented with an <code>_elem</code> suffix and the &#x27;</strong>&#x27; side is represented with a <code>_neighbor</code> suffix. We could just as well have chosen <code>_left</code> and <code>_right</code>, or <code>_1</code> and <code>_2</code>, or <code>_minus</code> and <code>_plus</code>, but for consistency with previous MOOSE framework code such as discontinuous Galerkin kernels and node-face constraints, we have elected to go with the <code>_elem</code> and <code>_neighbor</code> suffixes.</p></div></div></div><section id="af4472c2-3e53-47ee-9aad-5c7e921ffa46" data-section-level="2" data-section-text="FVKernels block"><h2 id="fvkernels-block">FVKernels block</h2><p>FVM kernels are added to simulation input files in the <code>FVKernels</code> block.  The <code>FVKernels</code> block in the example below sets up a transient diffusion problem defined by the equation:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-fcecdc94-ba33-4f93-917f-1d7c53e96e86"></span><script>var element = document.getElementById("moose-equation-fcecdc94-ba33-4f93-917f-1d7c53e96e86");katex.render("  \\frac{\\partial v}{\\partial t} - \\nabla \\cdot D \\nabla v = 0.", element, {displayMode:true,throwOnError:false});</script></span></p><p>The time derivative term corresponds to the kernel named <code>time</code>, while the diffusion term is represented by the kernel named <code>diff</code>.</p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 1: </span><span class="moose-caption-text" id="first_fv_kernel_example">Example of the FVKernels block in a MOOSE input file.</span></p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[FVKernels]
  [./time]
    type = FVFunctorTimeKernel
    variable = v
  [../]
  [diff]
    type = FVDiffusion
    variable = v
    coeff = coeff
  []
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#1732ec0e-b17d-4f2d-96b9-2e186b2e65f2">(moose/test/tests/fvkernels/fv_simple_diffusion/transient.i)</a></div></div><p>The <code>FVTimeKernel</code> in the example derives from <code>FVElementalKernel</code> so it&#x27;s a volumetric contribution to the residual, while the <code>FVDiffusion</code> kernel is an <code>FVFluxKernel</code> and it&#x27;s a face contribution to the residual. The remaining MOOSE syntax is what you would expect to see in finite element kernel objects:</p><p>* <code>variable</code> refers to the variable that this kernel is acting on (i.e. into   which equation does the residual of this term go).  This must be a   finite-volume variable (defined with <code>fv = true</code>) for all FVM kernels.</p><p>* <code>coeff</code> in kernel <code>diff</code> is a material property corresponding to the heat conduction or diffusion coefficient.</p><p>The next example shows an <code>FVKernels</code> block that solves the one-dimensional Burgers&#x27; equation. The Burgers&#x27; equation for speed <code>v</code> is given by:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-284e1c15-f1d9-4fd4-808b-230cb043b0ad"></span><script>var element = document.getElementById("moose-equation-284e1c15-f1d9-4fd4-808b-230cb043b0ad");katex.render("  \\frac{\\partial v}{\\partial t} + \\frac{1}{2}\\frac{\\partial }{\\partial x} v^2 = 0.", element, {displayMode:true,throwOnError:false});</script></span></p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 2: </span><span class="moose-caption-text" id="second_fv_kernel_example">Example of the FVKernels block in a MOOSE input file for solving one-dimensional Burgers&#x27; equation.</span></p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[FVKernels]
  [./burgers]
    type = FVBurgers1D
    variable = v
  [../]
  [./time]
    type = FVTimeKernel
    variable = v
  [../]
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#1ed7c458-dca4-42e3-bd29-4335ab5887a8">(moose/test/tests/fvkernels/fv_burgers/fv_burgers.i)</a></div></div><p>Note that the <code>FVBurgers1D</code> kernel only works for one-dimensional problems. In this example, the exact same time derivative kernels as for the diffusion example is used, but the spatial derivative term is different.</p><p>Boundary conditions are not discussed in these examples. Look at <a href="../FVBCs/index.html">syntax files</a> for details about boundary conditions.</p></section><section id="8522521d-8ed6-4dc1-b1df-a20155fb183a" data-section-level="2" data-section-text="Available Objects"><h2 id="available-objects">Available Objects</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/fvkernels/FVAdvection.html">FVAdvection</a>Residual contribution from advection operator for finite volume method.</li><li class="collection-item"><a href="../../source/fvkernels/FVAnisotropicDiffusion.html">FVAnisotropicDiffusion</a>Computes residual for anisotropic diffusion operator for finite volume method.</li><li class="collection-item"><a href="../../source/fvkernels/FVBodyForce.html">FVBodyForce</a>Demonstrates the multiple ways that scalar values can be introduced into finite volume kernels, e.g. (controllable) constants, functions, and postprocessors.</li><li class="collection-item"><a href="../../source/fvkernels/FVBoundedValueConstraint.html">FVBoundedValueConstraint</a>This class is used to enforce a min or max value for a finite volume variable</li><li class="collection-item"><a href="../../source/fvkernels/FVCoupledForce.html">FVCoupledForce</a>Implements a source term proportional to the value of a coupled variable.</li><li class="collection-item"><a href="../../source/fvkernels/FVDiffusion.html">FVDiffusion</a>Computes residual for diffusion operator for finite volume method.</li><li class="collection-item"><a href="../../source/fvkernels/FVFunctorTimeKernel.html">FVFunctorTimeKernel</a>Residual contribution from time derivative of an AD functor (default is the variable this kernel is acting upon if the &#x27;functor&#x27; parameter is not supplied)  for the finite volume method.</li><li class="collection-item"><a href="../../source/fvkernels/FVIntegralValueConstraint.html">FVIntegralValueConstraint</a>This class is used to enforce integral of phi = volume * phi_0 with a Lagrange multiplier approach.</li><li class="collection-item"><a href="../../source/fvkernels/FVMatAdvection.html">FVMatAdvection</a>Computes the residual of advective term using finite volume method.</li><li class="collection-item"><a href="../../source/fvkernels/FVOrthogonalDiffusion.html">FVOrthogonalDiffusion</a>Imposes an orthogonal diffusion term.</li><li class="collection-item"><a href="../../source/fvkernels/FVPointValueConstraint.html">FVPointValueConstraint</a>This class is used to enforce integral of phi = volume * phi_0 with a Lagrange multiplier approach.</li><li class="collection-item"><a href="../../source/fvkernels/FVReaction.html">FVReaction</a>Simple consuming reaction term</li><li class="collection-item"><a href="../../source/fvkernels/FVIntegralValueConstraint.html">FVScalarLagrangeMultiplier</a>This class is used to enforce integral of phi = volume * phi_0 with a Lagrange multiplier approach.</li><li class="collection-item"><a href="../../source/fvkernels/FVTimeKernel.html">FVTimeKernel</a>Residual contribution from time derivative of a variable for the finite volume method.</li></ul></section><section id="c0e310e3-defa-48d0-8203-65ad794d7f8f" data-section-level="2" data-section-text="FVKernel source code : FVDiffusion example"><h2 id="fvkernel-source-code-fvdiffusion-example">FVKernel source code: FVDiffusion example</h2><p>First, <code>FVFluxKernels</code> are discussed.  <code>FVFluxKernels</code> are used to calculate numerical flux contributions from face (surface integral) terms to the residual. The residual contribution is implemented by overriding the <code>computeQpResidual</code> function.</p><p>In the FVM, one solves for the averages of the variables over each element. The values of the variables on the faces are unknown and must be computed from the cell average values. This interpolation/reconstruction determines the accuracy of the FVM. The discussion is based on the example of <code>FVDiffusion</code> that discretizes the diffusion term using a central difference approximation.</p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 3: </span><span class="moose-caption-text" id="fv_diffusion_code">Example source code for a finite volume kernel discretizing the diffusion term using a central difference.</span></p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">
#include &quot;FVDiffusion.h&quot;

registerMooseObject(&quot;MooseApp&quot;, FVDiffusion);

InputParameters
FVDiffusion::validParams()
{
  InputParameters params = FVFluxKernel::validParams();
  params.addClassDescription(&quot;Computes residual for diffusion operator for finite volume method.&quot;);
  params.addRequiredParam&lt;MooseFunctorName&gt;(&quot;coeff&quot;, &quot;diffusion coefficient&quot;);
  MooseEnum coeff_interp_method(&quot;average harmonic&quot;, &quot;harmonic&quot;);
  params.addParam&lt;MooseEnum&gt;(
      &quot;coeff_interp_method&quot;,
      coeff_interp_method,
      &quot;Switch that can select face interpolation method for diffusion coefficients.&quot;);
  params.set&lt;unsigned short&gt;(&quot;ghost_layers&quot;) = 2;

  return params;
}

FVDiffusion::FVDiffusion(const InputParameters &amp; params)
  : FVFluxKernel(params),
    _coeff(getFunctor&lt;ADReal&gt;(&quot;coeff&quot;)),
    _coeff_interp_method(
        Moose::FV::selectInterpolationMethod(getParam&lt;MooseEnum&gt;(&quot;coeff_interp_method&quot;)))
{
  if ((_var.faceInterpolationMethod() == Moose::FV::InterpMethod::SkewCorrectedAverage) &amp;&amp;
      (_tid == 0))
    adjustRMGhostLayers(std::max((unsigned short)(3), _pars.get&lt;unsigned short&gt;(&quot;ghost_layers&quot;)));
}

ADReal
FVDiffusion::computeQpResidual()
{
  using namespace Moose::FV;
  const auto state = determineState();

  auto dudn = gradUDotNormal(state);
  ADReal coeff;

  // If we are on internal faces, we interpolate the diffusivity as usual
  if (_var.isInternalFace(*_face_info))
  {
    const ADReal coeff_elem = _coeff(elemArg(), state);
    const ADReal coeff_neighbor = _coeff(neighborArg(), state);
    // If the diffusion coefficients are zero, then we can early return 0 (and avoid warnings if we
    // have a harmonic interpolation)
    if (!coeff_elem.value() &amp;&amp; !coeff_neighbor.value())
      return 0;

    interpolate(_coeff_interp_method, coeff, coeff_elem, coeff_neighbor, *_face_info, true);
  }
  // Else we just use the boundary values (which depend on how the diffusion
  // coefficient is constructed)
  else
  {
    const auto face = singleSidedFaceArg();
    coeff = _coeff(face, state);
  }

  return -1 * coeff * dudn;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#8f390597-a658-41ac-96be-2ef2e7cb989e">(moose/framework/src/fvkernels/FVDiffusion.C)</a></div></div><p>The kernel <code>FVDiffusion</code> discretizes the diffusion term <span class="moose-katex-inline-equation" id="moose-equation-b706ca10-3c7c-4a9e-ab29-b6af0cdd958b"><script>var element = document.getElementById("moose-equation-b706ca10-3c7c-4a9e-ab29-b6af0cdd958b");katex.render("-\\nabla \\cdot D(v,\\vec{r}) \\nabla v", element, {displayMode:false,throwOnError:false});</script></span>. Integrating over the extend of an element and using Gauss&#x27; theorem leads to:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-5cf9d3b6-4fc3-449d-b3b4-51b3918cdf4b"></span><script>var element = document.getElementById("moose-equation-5cf9d3b6-4fc3-449d-b3b4-51b3918cdf4b");katex.render("-  \\int_{\\Omega} \\nabla \\cdot D(v,\\vec{r}) \\nabla v dV =  \\int_{\\partial \\Omega} \\left(-D(v, \\vec{r}) \\vec{n}\\cdot \\nabla v \\right) dS.", element, {displayMode:true,throwOnError:false});</script></span></p><p>The term in parenthesis in the surface integral on the right hand side must be implemented in the <code>FVKernel</code>. However, there is one more step before we can implement the kernel. We must determine how the values of <span class="moose-katex-inline-equation" id="moose-equation-1eb22a73-e5e4-4b5b-ab23-e59a8eea8d21"><script>var element = document.getElementById("moose-equation-1eb22a73-e5e4-4b5b-ab23-e59a8eea8d21");katex.render("D", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-cb272498-882c-4c4e-99e4-781a7bb51fe7"><script>var element = document.getElementById("moose-equation-cb272498-882c-4c4e-99e4-781a7bb51fe7");katex.render("\\nabla v", element, {displayMode:false,throwOnError:false});</script></span> depend on the values of <span class="moose-katex-inline-equation" id="moose-equation-9a752bd8-7c58-40f0-a7b7-7fd3c9dfa3a9"><script>var element = document.getElementById("moose-equation-9a752bd8-7c58-40f0-a7b7-7fd3c9dfa3a9");katex.render("D", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-2008a55c-d1bd-4ad7-b77e-4077c22fb3bf"><script>var element = document.getElementById("moose-equation-2008a55c-d1bd-4ad7-b77e-4077c22fb3bf");katex.render("v", element, {displayMode:false,throwOnError:false});</script></span> on the &#x27;+&#x27; and &#x27;-&#x27; side of the face <span class="moose-katex-inline-equation" id="moose-equation-e16ebbf8-3d1a-48fa-97d8-14af60cbfcaf"><script>var element = document.getElementById("moose-equation-e16ebbf8-3d1a-48fa-97d8-14af60cbfcaf");katex.render("\\partial \\Omega", element, {displayMode:false,throwOnError:false});</script></span>.  In this example, the following approximation is used:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-cf7435bf-29d0-42bc-ba74-dab0b12ad1dc"></span><script>var element = document.getElementById("moose-equation-cf7435bf-29d0-42bc-ba74-dab0b12ad1dc");katex.render("    \\left(-D(\\vec{r}) \\vec{n}\\cdot \\nabla v \\right) \\approx \\frac{D(v_L,\\vec{r}_L) + D(v_R,\\vec{r}_R)}{2} \\frac{v_R - v_L}{\\|\\vec{r}_R - \\vec{r}_L\\|}", element, {displayMode:true,throwOnError:false});</script></span></p><p>This is a central difference approximation of the gradient on the face that neglects cross diffusion terms.</p><p>Now, the implementation of this numerical flux into <code>FVDiffusion::computeQpResidual</code> is discussed.</p><p>* the kernel provides the &#x27;-&#x27; and &#x27;+&#x27; values of the variable <span class="moose-katex-inline-equation" id="moose-equation-4417e66f-21f4-46f0-ac17-1b4db63484f6"><script>var element = document.getElementById("moose-equation-4417e66f-21f4-46f0-ac17-1b4db63484f6");katex.render("v", element, {displayMode:false,throwOnError:false});</script></span> as <code>_u_elem[_qp]</code> and <code>_u_neighbor[_qp]</code></p><p>* the values of the material properties on the &#x27;-&#x27; side of the face is obtained by <code>_coeff_elem(getADMaterialProperty&lt;Real&gt;(&quot;coeff&quot;))</code> while the &#x27;+&#x27; side value is obtained by calling <code>getNeighborADMaterialProperty&lt;Real&gt;(&quot;coeff&quot;)</code>.</p><p>* geometric information about the &#x27;-&#x27; and &#x27;+&#x27; adjacent elements is available from the <code>face_info</code> object.</p><p>The implementation is then straight forward. The first line of the code computes <code>dudn</code> which corresponds to the term:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-1a5ca1e1-31fa-4c18-9041-3c408b811017"></span><script>var element = document.getElementById("moose-equation-1a5ca1e1-31fa-4c18-9041-3c408b811017");katex.render(" \\text{dudn} = \\frac{v_R - v_L}{\\|\\vec{r}_R - \\vec{r}_L\\|}", element, {displayMode:true,throwOnError:false});</script></span></p><p>while the second line computes <code>k</code> corresponding to:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-6bd4680d-38cd-4e05-b105-ec85cfb18282"></span><script>var element = document.getElementById("moose-equation-6bd4680d-38cd-4e05-b105-ec85cfb18282");katex.render("  \\text{k} = \\frac{D(v_L,\\vec{r}_L) + D(v_R,\\vec{r}_R)}{2} .", element, {displayMode:true,throwOnError:false});</script></span></p><p>The minus sign originates from the minus sign in the original expression. Flow from &#x27;-&#x27; to &#x27;+ is defined to be positive.</p></section><section id="cac4a0d8-8ba9-4e3c-8d05-96373e917dfc" data-section-level="2" data-section-text="FVKernel source code : FVMatAdvection example"><h2 id="fvkernel-source-code-fvmatadvection-example">FVKernel source code: FVMatAdvection example</h2><p>In this example the advection term:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-b706b3fd-f190-4a8c-971e-a0938ff12d7e"></span><script>var element = document.getElementById("moose-equation-b706b3fd-f190-4a8c-971e-a0938ff12d7e");katex.render("  \\nabla \\cdot \\left( \\vec{u} v \\right)", element, {displayMode:true,throwOnError:false});</script></span></p><p>is discretized using upwinding. The velocity is denoted by <span class="moose-katex-inline-equation" id="moose-equation-5c0c5392-4c86-4c3c-b6e2-784cf0565538"><script>var element = document.getElementById("moose-equation-5c0c5392-4c86-4c3c-b6e2-784cf0565538");katex.render("\\vec{u}", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-76734bd5-147d-4d37-a3f0-f65627ef828a"><script>var element = document.getElementById("moose-equation-76734bd5-147d-4d37-a3f0-f65627ef828a");katex.render("v", element, {displayMode:false,throwOnError:false});</script></span> represents a passive scalar quantity advected by the flow. Upwinding is a strategy that approximates the value of a variable on a face by taking the value from the upwind element (i.e. the element where the flow originates from).</p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 4: </span><span class="moose-caption-text" id="fv_mat_advection_code">Example source code for a finite volume kernel discretizing advection of a passive scalar.</span></p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">
#include &quot;FVDiffusion.h&quot;

registerMooseObject(&quot;MooseApp&quot;, FVDiffusion);

InputParameters
FVDiffusion::validParams()
{
  InputParameters params = FVFluxKernel::validParams();
  params.addClassDescription(&quot;Computes residual for diffusion operator for finite volume method.&quot;);
  params.addRequiredParam&lt;MooseFunctorName&gt;(&quot;coeff&quot;, &quot;diffusion coefficient&quot;);
  MooseEnum coeff_interp_method(&quot;average harmonic&quot;, &quot;harmonic&quot;);
  params.addParam&lt;MooseEnum&gt;(
      &quot;coeff_interp_method&quot;,
      coeff_interp_method,
      &quot;Switch that can select face interpolation method for diffusion coefficients.&quot;);
  params.set&lt;unsigned short&gt;(&quot;ghost_layers&quot;) = 2;

  return params;
}

FVDiffusion::FVDiffusion(const InputParameters &amp; params)
  : FVFluxKernel(params),
    _coeff(getFunctor&lt;ADReal&gt;(&quot;coeff&quot;)),
    _coeff_interp_method(
        Moose::FV::selectInterpolationMethod(getParam&lt;MooseEnum&gt;(&quot;coeff_interp_method&quot;)))
{
  if ((_var.faceInterpolationMethod() == Moose::FV::InterpMethod::SkewCorrectedAverage) &amp;&amp;
      (_tid == 0))
    adjustRMGhostLayers(std::max((unsigned short)(3), _pars.get&lt;unsigned short&gt;(&quot;ghost_layers&quot;)));
}

ADReal
FVDiffusion::computeQpResidual()
{
  using namespace Moose::FV;
  const auto state = determineState();

  auto dudn = gradUDotNormal(state);
  ADReal coeff;

  // If we are on internal faces, we interpolate the diffusivity as usual
  if (_var.isInternalFace(*_face_info))
  {
    const ADReal coeff_elem = _coeff(elemArg(), state);
    const ADReal coeff_neighbor = _coeff(neighborArg(), state);
    // If the diffusion coefficients are zero, then we can early return 0 (and avoid warnings if we
    // have a harmonic interpolation)
    if (!coeff_elem.value() &amp;&amp; !coeff_neighbor.value())
      return 0;

    interpolate(_coeff_interp_method, coeff, coeff_elem, coeff_neighbor, *_face_info, true);
  }
  // Else we just use the boundary values (which depend on how the diffusion
  // coefficient is constructed)
  else
  {
    const auto face = singleSidedFaceArg();
    coeff = _coeff(face, state);
  }

  return -1 * coeff * dudn;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#6a61c069-af88-49da-bdaa-1de8124fa58c">(moose/framework/src/fvkernels/FVDiffusion.C)</a></div></div><p>Integrating the advection term over the element and using Gauss&#x27; theorem leads to:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-3cb1d16b-e7d8-41c4-a4fe-b4618ced21e9"></span><script>var element = document.getElementById("moose-equation-3cb1d16b-e7d8-41c4-a4fe-b4618ced21e9");katex.render("   \\int_{\\Omega}   \\nabla \\cdot \\left( \\vec{u} v \\right) dV =    \\int_{\\partial \\Omega} \\left(\\vec{n} \\cdot \\vec{u} v \\right) dS.", element, {displayMode:true,throwOnError:false});</script></span></p><p>This term in parenthesis on the right hand side is approximated using upwinding:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-faed8898-a138-49b1-9139-8a7c18961cc6"></span><script>var element = document.getElementById("moose-equation-faed8898-a138-49b1-9139-8a7c18961cc6");katex.render("   \\vec{n} \\cdot \\vec{u} v \\approx  \\tilde{\\vec{u}}\\cdot \\vec{n}    \\tilde{v}    ,", element, {displayMode:true,throwOnError:false});</script></span></p><p>where</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-90c842b5-04cb-4836-a949-3163597361e5"></span><script>var element = document.getElementById("moose-equation-90c842b5-04cb-4836-a949-3163597361e5");katex.render("   \\tilde{\\vec{u}} = \\frac{1}{2} \\left( \\vec{u}_L + \\vec{u}_R \\right)", element, {displayMode:true,throwOnError:false});</script></span></p><p>and  <span class="moose-katex-inline-equation" id="moose-equation-7124e9fb-4dd3-487c-b744-55952d4ddd14"><script>var element = document.getElementById("moose-equation-7124e9fb-4dd3-487c-b744-55952d4ddd14");katex.render("\\tilde{v} = v_L", element, {displayMode:false,throwOnError:false});</script></span> if <span class="moose-katex-inline-equation" id="moose-equation-9e26dbfe-09b2-4c68-a5ed-9e0b234774f3"><script>var element = document.getElementById("moose-equation-9e26dbfe-09b2-4c68-a5ed-9e0b234774f3");katex.render("\\tilde{\\vec{u}} \\cdot \\vec{n} > 0", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-8bdb72da-48cf-4b41-9fbd-e8c69463dcc5"><script>var element = document.getElementById("moose-equation-8bdb72da-48cf-4b41-9fbd-e8c69463dcc5");katex.render("\\tilde{v} = v_R", element, {displayMode:false,throwOnError:false});</script></span> otherwise. By convention, the normal <span class="moose-katex-inline-equation" id="moose-equation-dfb30e77-22fe-4aeb-801f-ba886bce3f1b"><script>var element = document.getElementById("moose-equation-dfb30e77-22fe-4aeb-801f-ba886bce3f1b");katex.render("\\vec{n}", element, {displayMode:false,throwOnError:false});</script></span> points from the &#x27;-&#x27; side to the &#x27;+&#x27; side.</p><p>The implementation is straight forward. In the constructor the &#x27;-&#x27; and &#x27;<strong>&#x27; velocities are obtained as <code>RealVectorValue</code> material properties. The average is computed and stored in variable <code>v_avg</code>. The direction of the flow is determined using the inner product of <code>v_avg * _normal</code> and the residual is then computed using either the &#x27;-&#x27; value of <span class="moose-katex-inline-equation" id="moose-equation-47efa32f-d747-4ab9-9509-8c27185c6aa5"><script>var element = document.getElementById("moose-equation-47efa32f-d747-4ab9-9509-8c27185c6aa5");katex.render("v", element, {displayMode:false,throwOnError:false});</script></span> given by <code>_u_elem[_qp]</code> or the &#x27;</strong>&#x27; value given by <code>_u_neighbor [_qp]</code>.</p></section><section id="4061e25e-34cb-447c-8dc0-1f761df76d72" data-section-level="2" data-section-text="FVKernel source code : FVTimeKernel"><h2 id="fvkernel-source-code-fvtimekernel">FVKernel source code: FVTimeKernel</h2><p>This example demonstrates source code for an <code>FVElementalKernel</code>. <code>FVElementalKernel</code> are volumetric terms. In this case, the kernel is <code>FVTimeKernel</code>.</p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 5: </span><span class="moose-caption-text" id="fv_time_code">Example source code for the finite volume time kernel.</span></p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">FVTimeKernel::computeQpResidual()
{
  return _u_dot[_qp];
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#6d1ec7c6-1b46-445e-923a-baa1e1268732">(moose/framework/src/fvkernels/FVTimeKernel.C)</a></div></div><p>This kernel implements the term:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-0440aec1-95a2-4036-9683-49a126873db7"></span><script>var element = document.getElementById("moose-equation-0440aec1-95a2-4036-9683-49a126873db7");katex.render("  \\frac{\\partial v}{\\partial t}", element, {displayMode:true,throwOnError:false});</script></span></p><p>The implementation is identical to the implementation of FEM kernels except that the FVM does not require multiplication by the test function. </p></section></section><div class="moose-modal modal" id="1732ec0e-b17d-4f2d-96b9-2e186b2e65f2"><div class="modal-content"><h4>(moose/test/tests/fvkernels/fv_simple_diffusion/transient.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [v]
    family = MONOMIAL
    order = CONSTANT
    fv = true
    initial_condition = 7
  []
[]

[Kernels]
[]

[FVKernels]
  [./time]
    type = FVFunctorTimeKernel
    variable = v
  [../]
  [diff]
    type = FVDiffusion
    variable = v
    coeff = coeff
  []
[]

[FVBCs]
  [left]
    type = FVDirichletBC
    variable = v
    boundary = left
    value = 7
  []
  [right]
    type = FVDirichletBC
    variable = v
    boundary = right
    value = 42
  []
[]

[Materials]
  [diff]
    type = ADGenericFunctorMaterial
    prop_names = &#x27;coeff&#x27;
    prop_values = &#x27;.2&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = &#x27;NEWTON&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  residual_and_jacobian_together = true
  num_steps = 20
  dt = 0.1
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="1ed7c458-dca4-42e3-bd29-4335ab5887a8"><div class="modal-content"><h4>(moose/test/tests/fvkernels/fv_burgers/fv_burgers.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./gen_mesh]
    type = GeneratedMeshGenerator
    dim = 1
    xmin = 0
    xmax = 10
    nx = 50
  [../]
[]

[Variables]
  [./v]
    family = MONOMIAL
    order = CONSTANT
    fv = true
  [../]
[]

[ICs]
  [./v_ic]
    type = FunctionIC
    variable = v
    function = &#x27;if (x &gt; 2 &amp; x &lt; 3, 0.5, 0)&#x27;
  [../]
[]

[FVKernels]
  [./burgers]
    type = FVBurgers1D
    variable = v
  [../]
  [./time]
    type = FVTimeKernel
    variable = v
  [../]
[]

[FVBCs]
  [./fv_burgers_outflow]
    type = FVBurgersOutflowBC
    variable = v
    boundary = &#x27;left right&#x27;
  [../]
[]

[Executioner]
  type = Transient
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  petsc_options = &#x27;-snes_converged_reason&#x27;
  nl_abs_tol = 1e-7
  nl_rel_tol = 1e-8
  num_steps = 5
  dt = 0.05
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="8f390597-a658-41ac-96be-2ef2e7cb989e"><div class="modal-content"><h4>(moose/framework/src/fvkernels/FVDiffusion.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;FVDiffusion.h&quot;

registerMooseObject(&quot;MooseApp&quot;, FVDiffusion);

InputParameters
FVDiffusion::validParams()
{
  InputParameters params = FVFluxKernel::validParams();
  params.addClassDescription(&quot;Computes residual for diffusion operator for finite volume method.&quot;);
  params.addRequiredParam&lt;MooseFunctorName&gt;(&quot;coeff&quot;, &quot;diffusion coefficient&quot;);
  MooseEnum coeff_interp_method(&quot;average harmonic&quot;, &quot;harmonic&quot;);
  params.addParam&lt;MooseEnum&gt;(
      &quot;coeff_interp_method&quot;,
      coeff_interp_method,
      &quot;Switch that can select face interpolation method for diffusion coefficients.&quot;);
  params.set&lt;unsigned short&gt;(&quot;ghost_layers&quot;) = 2;

  return params;
}

FVDiffusion::FVDiffusion(const InputParameters &amp; params)
  : FVFluxKernel(params),
    _coeff(getFunctor&lt;ADReal&gt;(&quot;coeff&quot;)),
    _coeff_interp_method(
        Moose::FV::selectInterpolationMethod(getParam&lt;MooseEnum&gt;(&quot;coeff_interp_method&quot;)))
{
  if ((_var.faceInterpolationMethod() == Moose::FV::InterpMethod::SkewCorrectedAverage) &amp;&amp;
      (_tid == 0))
    adjustRMGhostLayers(std::max((unsigned short)(3), _pars.get&lt;unsigned short&gt;(&quot;ghost_layers&quot;)));
}

ADReal
FVDiffusion::computeQpResidual()
{
  using namespace Moose::FV;
  const auto state = determineState();

  auto dudn = gradUDotNormal(state);
  ADReal coeff;

  // If we are on internal faces, we interpolate the diffusivity as usual
  if (_var.isInternalFace(*_face_info))
  {
    const ADReal coeff_elem = _coeff(elemArg(), state);
    const ADReal coeff_neighbor = _coeff(neighborArg(), state);
    // If the diffusion coefficients are zero, then we can early return 0 (and avoid warnings if we
    // have a harmonic interpolation)
    if (!coeff_elem.value() &amp;&amp; !coeff_neighbor.value())
      return 0;

    interpolate(_coeff_interp_method, coeff, coeff_elem, coeff_neighbor, *_face_info, true);
  }
  // Else we just use the boundary values (which depend on how the diffusion
  // coefficient is constructed)
  else
  {
    const auto face = singleSidedFaceArg();
    coeff = _coeff(face, state);
  }

  return -1 * coeff * dudn;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="6a61c069-af88-49da-bdaa-1de8124fa58c"><div class="modal-content"><h4>(moose/framework/src/fvkernels/FVDiffusion.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;FVDiffusion.h&quot;

registerMooseObject(&quot;MooseApp&quot;, FVDiffusion);

InputParameters
FVDiffusion::validParams()
{
  InputParameters params = FVFluxKernel::validParams();
  params.addClassDescription(&quot;Computes residual for diffusion operator for finite volume method.&quot;);
  params.addRequiredParam&lt;MooseFunctorName&gt;(&quot;coeff&quot;, &quot;diffusion coefficient&quot;);
  MooseEnum coeff_interp_method(&quot;average harmonic&quot;, &quot;harmonic&quot;);
  params.addParam&lt;MooseEnum&gt;(
      &quot;coeff_interp_method&quot;,
      coeff_interp_method,
      &quot;Switch that can select face interpolation method for diffusion coefficients.&quot;);
  params.set&lt;unsigned short&gt;(&quot;ghost_layers&quot;) = 2;

  return params;
}

FVDiffusion::FVDiffusion(const InputParameters &amp; params)
  : FVFluxKernel(params),
    _coeff(getFunctor&lt;ADReal&gt;(&quot;coeff&quot;)),
    _coeff_interp_method(
        Moose::FV::selectInterpolationMethod(getParam&lt;MooseEnum&gt;(&quot;coeff_interp_method&quot;)))
{
  if ((_var.faceInterpolationMethod() == Moose::FV::InterpMethod::SkewCorrectedAverage) &amp;&amp;
      (_tid == 0))
    adjustRMGhostLayers(std::max((unsigned short)(3), _pars.get&lt;unsigned short&gt;(&quot;ghost_layers&quot;)));
}

ADReal
FVDiffusion::computeQpResidual()
{
  using namespace Moose::FV;
  const auto state = determineState();

  auto dudn = gradUDotNormal(state);
  ADReal coeff;

  // If we are on internal faces, we interpolate the diffusivity as usual
  if (_var.isInternalFace(*_face_info))
  {
    const ADReal coeff_elem = _coeff(elemArg(), state);
    const ADReal coeff_neighbor = _coeff(neighborArg(), state);
    // If the diffusion coefficients are zero, then we can early return 0 (and avoid warnings if we
    // have a harmonic interpolation)
    if (!coeff_elem.value() &amp;&amp; !coeff_neighbor.value())
      return 0;

    interpolate(_coeff_interp_method, coeff, coeff_elem, coeff_neighbor, *_face_info, true);
  }
  // Else we just use the boundary values (which depend on how the diffusion
  // coefficient is constructed)
  else
  {
    const auto face = singleSidedFaceArg();
    coeff = _coeff(face, state);
  }

  return -1 * coeff * dudn;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="6d1ec7c6-1b46-445e-923a-baa1e1268732"><div class="modal-content"><h4>(moose/framework/src/fvkernels/FVTimeKernel.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;FVTimeKernel.h&quot;

#include &quot;SystemBase.h&quot;

registerADMooseObject(&quot;MooseApp&quot;, FVTimeKernel);

InputParameters
FVTimeKernel::validParams()
{
  InputParameters params = FVElementalKernel::validParams();
  params.addClassDescription(
      &quot;Residual contribution from time derivative of a variable for the finite volume method.&quot;);
  params.set&lt;MultiMooseEnum&gt;(&quot;vector_tags&quot;) = &quot;time&quot;;
  params.set&lt;MultiMooseEnum&gt;(&quot;matrix_tags&quot;) = &quot;system time&quot;;
  return params;
}

FVTimeKernel::FVTimeKernel(const InputParameters &amp; parameters)
  : FVElementalKernel(parameters), _u_dot(_var.adUDot())
{
  _var.requireQpComputations();
}

ADReal
FVTimeKernel::computeQpResidual()
{
  return _u_dot[_qp];
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>