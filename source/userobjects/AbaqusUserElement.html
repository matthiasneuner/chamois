<!DOCTYPE html><head><meta charset="UTF-8"><title>AbaqusUserElement | Chamois</title><link rel="icon" type="image/x-icon" href="../../media/chamois_logo.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Chamois</a><a href="https://github.com/matthiasneuner/chamois" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="../../getting_started.html">Getting Started</a></li><li><a href="../../singularity.html">Singularity container</a></li><li><a href="../../publications.html">Publications</a></li><li><a href="../../contributors.html">Contributors</a></li><li><a href="#!" class="dropdown-trigger" data-target="956f38ee-a6eb-4980-be45-a7572b674a99" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li></ul><a href="#" class="sidenav-trigger" data-target="063f9f0a-d5b4-4921-9c23-5a47d24c36ed"><i class="material-icons">menu</i></a><ul class="sidenav" id="063f9f0a-d5b4-4921-9c23-5a47d24c36ed"><li><a href="../../getting_started.html">Getting Started</a></li><li><a href="../../singularity.html">Singularity container</a></li><li><a href="../../publications.html">Publications</a></li><li><a href="../../contributors.html">Contributors</a></li><li><a href="#!" class="dropdown-trigger" data-target="be29e553-de0c-41e6-a671-fdc901974ecb" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="956f38ee-a6eb-4980-be45-a7572b674a99"><li><a href="../../syntax/chamois.html">Chamois syntax</a></li></ul><ul class="dropdown-content" id="be29e553-de0c-41e6-a671-fdc901974ecb"><li><a href="../../syntax/chamois.html">Chamois syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="be98be56-73c0-46ca-bcb8-472aba38222e" data-section-level="1" data-section-text="AbaqusUserElement"><h1 id="abaqususerelement">AbaqusUserElement</h1><p>Coupling UserObject to use Abaqus UEL plugins in MOOSE</p><section id="eac202fd-2b0d-453c-a25f-1946d4b8d1d8" data-section-level="2" data-section-text="Description"><h2 id="description">Description</h2><p>The <code>AbaqusUserElement</code> user object is used to execute Abaqus UEL plugins that users code with the purpose of building finite element kinematics (i.e. interpolation functions), numerical treatments (e.g. locking correction), Jacobian of the forces with respect to the displacements and the forces themselves. These plug-ins can be coded in Fortran (<code>.f</code> and <code>.f90</code> file extensions) or C/C++  (<code>.c</code> and <code>.C</code> file extensions) and can be located in the <code>plugins</code> directory of the app or another appropriate directory such as <code>examples</code>.</p><p>Note that one can combine a UEL routine with UMAT routines such that the UEL coder is responsible for calling a UMAT routine compiled within the same plugin.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p>When state variables are needed, the user is responsible for prescribing them in the input files via <code>num_state_vars =</code> in the <code>AbaqusUserElement</code> user object.</p></div></div></div><p>Various forms of verification of this interface have been carried out. The most general is that defined by a beam subjected to external loading. The internal forces are a function of strain-dependent state variables and two external fields that vary spatially. Results between a UEL of triangular elements and the corresponding model set up in MOOSE with a call to an equivalent UMAT routine match to a relative tolerance of <span class="moose-katex-inline-equation" id="moose-equation-02b1fa2f-3671-4411-9bb4-a74d57e86764"><script>var element = document.getElementById("moose-equation-02b1fa2f-3671-4411-9bb4-a74d57e86764");katex.render("10^{-6}", element, {displayMode:false,throwOnError:false});</script></span>.</p><p>The input file that calls the UEL does so from the <code>AbaqusUserElement</code> block:</p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[UserObjects]
  [uel]
    type = AbaqusUserElement
    variables = &#x27;disp_x disp_y&#x27;
    plugin = ../../../examples/uel_tri_states_tests/uel
    use_displaced_mesh = false
    num_state_vars = 8
    constant_properties = &#x27;100 0.3&#x27; # E nu
    external_fields = &#x27;temperature voltage&#x27;
    extra_vector_tags = &#x27;kernel_residual&#x27;
  []
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#62e5ab51-5241-4e83-8796-d4c178c3de26">(moose/modules/tensor_mechanics/test/tests/uel/small_test_uel_states_fields_gradient.i)</a><p>The equivalent input file that performs all the setup in MOOSE, except the computation of internal forces, uses the <code>AbaqusUMATStress</code> plugin.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[umat]
  type = AbaqusUMATStress
  constant_properties = &#x27;100 0.3&#x27;
  plugin = &#x27;../../plugins/small_elastic_tri_states&#x27;
  num_state_vars = 2
  use_one_based_indexing = true
  temperature = &#x27;temperature&#x27;
  external_fields = &#x27;voltage&#x27;
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#4a58b62e-8237-4a3d-b908-ad936657a080">(moose/modules/tensor_mechanics/test/tests/uel/small_test_umat_states_fields_gradient.i)</a></section><section id="78aa715c-4825-4421-961e-d3bedc6ac932" data-section-level="2" data-section-text="Interface"><h2 id="interface">Interface</h2><p>The UEL plugin entry function signature is defined in the <code>AbaqusUserElement.h</code> header file</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  typedef void (*uel_t)(
      Real RHS[],    // (MLVARX,*)      Residual vector contribution for the current element
      Real AMATRX[], // (NDOFEL,NDOFEL) Jacobian contribution for the current element
      Real SVARS[],  // (NSVARS)        Persistent state variable values for the current element
      Real ENERGY[], // (8)             Energy quantities at the start of the current
                     //                 increment (to be updated by the UEL routine)
      int * NDOFEL,  // Number of degrees of freedom (DOFs) for the current element
      int * NRHS,    // NRHS=1: RHS should contain the residual vector,
                     // NRHS=2: not implemented (modified Riks static procedure)
      int * NSVARS,  // Number of persistent state variables for the element
      Real PROPS[],  // (NPROPS) Static property values (parameters) defined for use with this
                     // element.
      int * NPROPS,  //
      Real COORDS[], // (MCRD,NNODE) Undisplaced coordinates of the element nodes
                     //              COORDS(K1,K2) is the K1th coordinate of the
                     //              K2th node of the element
      int * MCRD,  // Maximum number of coordinates needed at any node point (COORDINATES keyword -
                   // unsupported)
      int * NNODE, // Number of nodes in the current element
      Real U[],    // (NDOFEL)   Total values of the variables
      Real DU[],   // (MLVARX,*) Incremental values of the variables for the current increment
                   //            for right-hand-side
      Real V[],    // (NDOFEL) Time rate of change of the variables (velocities,
                   //          rates of rotation). Defined for implicit dynamics only (LFLAGS(1)
                   //          11 or 12)
      Real A[],    // (NDOFEL) Accelerations of the variables. Defined for implicit dynamics
                   //          only (LFLAGS(1) 11 or 12).
      int * JTYPE, // Integer defining the element type. This is the user-defined integer value n in
                   // element type Un
      Real TIME[], // (2) step time and total time
      Real * DTIME,  // Time increment
      int * KSTEP,   // Step number (as per Abaqus definition) can be set by the user
      int * KINC,    // Increment number (MOOSE time step)
      int * JELEM,   // User-defined element number
      Real PRAMS[],  // (*) parameters associated with the solution procedure
      int * NDLOAD,  // Number of applied loads to the element (unused)
      int JDLTYP[],  // (MDLOAD, *) array containing the integers used to define distributed load
                     //             types for the element
      Real ADLMAG[], // (MDLOAD,*)
      Real PREDEF[], // (2,NPREDF,NNODE) predefined field variables, such as temperature in an
                     //                  uncoupled stress/displacement analysis
      int * NPREDF,  // Number of predefined field (auxiliary) variables, including temperature
      int LFLAGS[],  // (*) flags that define the current solution procedure
      int * MLVARX,  // used when several displacement or right-hand-side vectors are used
      Real DDLMAG[], // (MDLOAD,*)
      int * MDLOAD,  // Total number of distributed loads and/or fluxes defined on this element
      Real * PNEWDT, // Recommended new timestep (unused)
      int JPROPS[],  // (NJPROP) NJPROP integer property values defined for the current element
      int * NJPROP,  // Number of user defined integer properties
      Real * PERIOD  // Current step time period (unused)
  );
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#0e762913-b4a4-4553-9b31-6db8bea7c104">(moose/modules/tensor_mechanics/include/userobjects/AbaqusUserElement.h)</a><section id="1c20534c-9ac9-4542-8767-a78f59acc241" data-section-level="3" data-section-text="Output parameters"><h3 id="output-parameters">Output parameters</h3><p>The UEL routine sets <code>RHS</code>, <code>AMATRX</code>, <code>SVARS</code>, <code>ENERGY</code>, and <code>PNEWDT</code></p><ul class="browser-default"><li><p><code>RHS</code> is the residual contribution for the DOFs associated with the current element </p></li><li><p><code>AMATRIX</code> are the Jacobian contributions for the DOFs associated with the current element </p></li><li><p><code>SVARS</code> are stateful properties (persistent across timesteps) that are managed by the user object similar to stateful material properties in MOOSE </p></li><li><p><code>ENERGY</code> array of 6 energy quantities (currently not used by MOOSE)</p><ol class="browser-default" start="1"><li><p>Kinetic energy. </p></li><li><p>Elastic strain energy. </p></li><li><p>Creep dissipation. </p></li><li><p>Plastic dissipation. </p></li><li><p>Viscous dissipation. </p></li><li><p>Artificial strain energy stemming from e.g. artificial stiffness to control singular modes </p></li><li><p>Electroststic energy </p></li><li><p>Incremental work done by loads applied through the UEL routine</p></li></ol><p></p></li><li><p><code>PNEWDT</code> is a new recommended simulation time step (currently not used by MOOSE)</p></li></ul></section><section id="86f5aa87-1b39-4380-8566-6d8d0c3ff39f" data-section-level="3" data-section-text="Input parameters"><h3 id="input-parameters">Input parameters</h3><p>Please consult the Abaqus user manual for more documentation on the UEL plugin parameters.</p></section></section><section id="b3b0e1ab-d432-4817-b690-ce2d03858ab6" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="669c01b5-4ab6-4194-973d-7406d3352e06" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">constant_properties</span><span class="moose-parameter-header-description">Constant mechanical and thermal material properties (PROPS)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;double&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Constant mechanical and thermal material properties (PROPS)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">num_state_vars</span><span class="moose-parameter-header-description">The number of state variables this UMAT is going to use</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The number of state variables this UMAT is going to use</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">plugin</span><span class="moose-parameter-header-description">UEL plugin file</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>FileName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>UEL plugin file</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="acd597d4-d513-45de-8b09-becc4d11ce68" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">block</span><span class="moose-parameter-header-description">The list of blocks (ids or names) that this object will be applied</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The list of blocks (ids or names) that this object will be applied</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">external_fields</span><span class="moose-parameter-header-description">Auxiliary field variables (or 'predifined field variables') passed to the UEL plugin. Some plugins may assume that the first field is temperature when there are multiple external fields.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;AuxVariableName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Auxiliary field variables (or 'predifined field variables') passed to the UEL plugin. Some plugins may assume that the first field is temperature when there are multiple external fields.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">jtype</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">Abaqus element type integer</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Abaqus element type integer</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">prop_getter_suffix</span><span class="moose-parameter-header-description">An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">variables</span><span class="moose-parameter-header-description">Nonlinear coupled variables</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;NonlinearVariableName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Nonlinear coupled variables</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="e1e80e1c-8c79-42e8-ae95-1b2c7e486387" data-section-level="3" data-section-text="Tagging Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">absolute_value_vector_tags</span><span class="moose-parameter-header-description">The tags for the vectors this residual object should fill with the absolute value of the residual contribution</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;TagName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The tags for the vectors this residual object should fill with the absolute value of the residual contribution</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">extra_matrix_tags</span><span class="moose-parameter-header-description">The extra tags for the matrices this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;TagName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The extra tags for the matrices this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">extra_vector_tags</span><span class="moose-parameter-header-description">The extra tags for the vectors this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;TagName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The extra tags for the vectors this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">matrix_tags</span><span class="moose-parameter-header-default">system</span><span class="moose-parameter-header-description">The tag for the matrices this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>system</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>nontime, system</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The tag for the matrices this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">vector_tags</span><span class="moose-parameter-header-default">nontime</span><span class="moose-parameter-header-description">The tag for the vectors this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>nontime</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>nontime, time</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The tag for the vectors this Kernel should fill</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Tagging Parameters</h3></summary></details></section><section id="b9ed61ed-ad1c-488d-bb9f-eb5943e18c1a" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">allow_duplicate_execution_on_initial</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">In the case where this UserObject is depended upon by an initial condition, allow it to be executed twice during the initial setup (once before the IC and again after mesh adaptivity (if applicable).</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>In the case where this UserObject is depended upon by an initial condition, allow it to be executed twice during the initial setup (once before the IC and again after mesh adaptivity (if applicable).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>Yes</p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">execution_order_group</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">Execution order groups are executed in increasing order (e.g., the lowest number is executed first). Note that negative group numbers may be used to execute groups before the default (0) group. Please refer to the user object documentation for ordering of user object execution within a group.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Execution order groups are executed in increasing order (e.g., the lowest number is executed first). Note that negative group numbers may be used to execute groups before the default (0) group. Please refer to the user object documentation for ordering of user object execution within a group.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">force_postaux</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Forces the UserObject to be executed in POSTAUX</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Forces the UserObject to be executed in POSTAUX</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">force_preaux</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Forces the UserObject to be executed in PREAUX</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Forces the UserObject to be executed in PREAUX</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_displaced_mesh</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section></section></section><div class="moose-modal modal" id="62e5ab51-5241-4e83-8796-d4c178c3de26"><div class="modal-content"><h4>(moose/modules/tensor_mechanics/test/tests/uel/small_test_uel_states_fields_gradient.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 20
    ny = 10
    xmax = 10
    ymax = 3
    elem_type = TRI3
  []
  [pin]
    type = ExtraNodesetGenerator
    nodes = 106
    new_boundary = pin
    input = gen
  []
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [disp_x]
  []
  [disp_y]
  []
[]

[AuxVariables]
  [temperature]
    initial_condition = 400
  []
  [voltage]
    initial_condition = 210
  []
[]

[AuxKernels]
  [temperature]
    type = FunctionAux
    function = &#x27;25* x + 40 * y + 400&#x27;
    variable = temperature
  []
  [voltage]
    type = FunctionAux
    function = &#x27;10 * x + 4 * y + 210&#x27;
    variable = voltage
  []
[]

[BCs]
  [left_x]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0
  []
  [left_y]
    type = DirichletBC
    variable = disp_y
    boundary = pin
    value = 0
  []

  inactive = &#x27;right_dirichlet&#x27;
  [right_neumann]
    type = FunctionNeumannBC
    variable = disp_x
    function = t/10
    boundary = right
  []
  [right_dirichlet]
    type = FunctionDirichletBC
    variable = disp_x
    function = t/10
    boundary = right
  []
[]

[UserObjects]
  [uel]
    type = AbaqusUserElement
    variables = &#x27;disp_x disp_y&#x27;
    plugin = ../../../examples/uel_tri_states_tests/uel
    use_displaced_mesh = false
    num_state_vars = 8
    constant_properties = &#x27;100 0.3&#x27; # E nu
    external_fields = &#x27;temperature voltage&#x27;
    extra_vector_tags = &#x27;kernel_residual&#x27;
  []
[]

[Problem]
  kernel_coverage_check = false
  extra_tag_vectors = &#x27;kernel_residual&#x27;
[]

[AuxVariables]
  [res_x]
  []
  [res_y]
  []
[]

[AuxKernels]
  [res_x]
    type = TagVectorAux
    variable = res_x
    v = disp_x
    vector_tag = kernel_residual
  []
  [res_y]
    type = TagVectorAux
    variable = res_y
    v = disp_y
    vector_tag = kernel_residual
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  dt = 1
  num_steps = 15
[]

[Postprocessors]
  [delta_l]
    type = SideAverageValue
    variable = disp_x
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ElementIntegralMaterialProperty
    mat_prop = 1
    use_displaced_mesh = true
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="4a58b62e-8237-4a3d-b908-ad936657a080"><div class="modal-content"><h4>(moose/modules/tensor_mechanics/test/tests/uel/small_test_umat_states_fields_gradient.i)</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 20
    ny = 10
    xmax = 10
    ymax = 3
    elem_type = TRI3
  []
  [pin]
    type = ExtraNodesetGenerator
    nodes = 106
    new_boundary = pin
    input = gen
  []
  displacements = &#x27;disp_x disp_y&#x27;
[]

[AuxVariables]
  [temperature]
    initial_condition = 400
  []
  [voltage]
    initial_condition = 210
  []
[]

[AuxKernels]
  [temperature]
    type = FunctionAux
    function = &#x27;25* x + 40 * y + 400&#x27;
    variable = temperature
  []
  [voltage]
    type = FunctionAux
    function = &#x27;10 * x + 4 * y + 210&#x27;
    variable = voltage
  []
[]

[BCs]
  [left_x]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0
  []
  [left_y]
    type = DirichletBC
    variable = disp_y
    boundary = pin
    value = 0
  []

  inactive = &#x27;right_dirichlet&#x27;
  [right_neumann]
    type = FunctionNeumannBC
    variable = disp_x
    function = t/10
    boundary = right
  []
  [right_dirichlet]
    type = FunctionDirichletBC
    variable = disp_x
    function = t/10
    boundary = right
  []
[]

[Modules/TensorMechanics/Master]
  [all]
    add_variables = true
    strain = SMALL
    incremental = true
    extra_vector_tags = &#x27;kernel_residual&#x27;
  []
[]

[Materials]
  [umat]
    type = AbaqusUMATStress
    constant_properties = &#x27;100 0.3&#x27;
    plugin = &#x27;../../plugins/small_elastic_tri_states&#x27;
    num_state_vars = 2
    use_one_based_indexing = true
    temperature = &#x27;temperature&#x27;
    external_fields = &#x27;voltage&#x27;
  []
[]

[Problem]
  kernel_coverage_check = false
  extra_tag_vectors = &#x27;kernel_residual&#x27;
[]

[AuxVariables]
  [res_x]
  []
  [res_y]
  []
[]

[AuxKernels]
  [res_x]
    type = TagVectorAux
    variable = res_x
    v = disp_x
    vector_tag = kernel_residual
  []
  [res_y]
    type = TagVectorAux
    variable = res_y
    v = disp_y
    vector_tag = kernel_residual
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  dt = 1
  num_steps = 15
  [Quadrature]
   type = GAUSS
   order = CONSTANT
  []
[]

[Postprocessors]
  [delta_l]
    type = SideAverageValue
    variable = disp_x
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ElementIntegralMaterialProperty
    mat_prop = 1
    use_displaced_mesh = true
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="0e762913-b4a4-4553-9b31-6db8bea7c104"><div class="modal-content"><h4>(moose/modules/tensor_mechanics/include/userobjects/AbaqusUserElement.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;GeneralUserObject.h&quot;
#include &quot;BlockRestrictable.h&quot;
#include &quot;TaggingInterface.h&quot;
#include &quot;DynamicLibraryLoader.h&quot;

class MooseMesh;
namespace libMesh
{
class Elem;
class MeshBase;
}

/**
 * This user-object is a testbed for implementing a custom element.
 */
class AbaqusUserElement : public GeneralUserObject,
                          public BlockRestrictable,
                          public TaggingInterface
{
public:
  /// function type for the external UMAT function
  typedef void (*uel_t)(
      Real RHS[],    // (MLVARX,*)      Residual vector contribution for the current element
      Real AMATRX[], // (NDOFEL,NDOFEL) Jacobian contribution for the current element
      Real SVARS[],  // (NSVARS)        Persistent state variable values for the current element
      Real ENERGY[], // (8)             Energy quantities at the start of the current
                     //                 increment (to be updated by the UEL routine)
      int * NDOFEL,  // Number of degrees of freedom (DOFs) for the current element
      int * NRHS,    // NRHS=1: RHS should contain the residual vector,
                     // NRHS=2: not implemented (modified Riks static procedure)
      int * NSVARS,  // Number of persistent state variables for the element
      Real PROPS[],  // (NPROPS) Static property values (parameters) defined for use with this
                     // element.
      int * NPROPS,  //
      Real COORDS[], // (MCRD,NNODE) Undisplaced coordinates of the element nodes
                     //              COORDS(K1,K2) is the K1th coordinate of the
                     //              K2th node of the element
      int * MCRD,  // Maximum number of coordinates needed at any node point (COORDINATES keyword -
                   // unsupported)
      int * NNODE, // Number of nodes in the current element
      Real U[],    // (NDOFEL)   Total values of the variables
      Real DU[],   // (MLVARX,*) Incremental values of the variables for the current increment
                   //            for right-hand-side
      Real V[],    // (NDOFEL) Time rate of change of the variables (velocities,
                   //          rates of rotation). Defined for implicit dynamics only (LFLAGS(1)
                   //          11 or 12)
      Real A[],    // (NDOFEL) Accelerations of the variables. Defined for implicit dynamics
                   //          only (LFLAGS(1) 11 or 12).
      int * JTYPE, // Integer defining the element type. This is the user-defined integer value n in
                   // element type Un
      Real TIME[], // (2) step time and total time
      Real * DTIME,  // Time increment
      int * KSTEP,   // Step number (as per Abaqus definition) can be set by the user
      int * KINC,    // Increment number (MOOSE time step)
      int * JELEM,   // User-defined element number
      Real PRAMS[],  // (*) parameters associated with the solution procedure
      int * NDLOAD,  // Number of applied loads to the element (unused)
      int JDLTYP[],  // (MDLOAD, *) array containing the integers used to define distributed load
                     //             types for the element
      Real ADLMAG[], // (MDLOAD,*)
      Real PREDEF[], // (2,NPREDF,NNODE) predefined field variables, such as temperature in an
                     //                  uncoupled stress/displacement analysis
      int * NPREDF,  // Number of predefined field (auxiliary) variables, including temperature
      int LFLAGS[],  // (*) flags that define the current solution procedure
      int * MLVARX,  // used when several displacement or right-hand-side vectors are used
      Real DDLMAG[], // (MDLOAD,*)
      int * MDLOAD,  // Total number of distributed loads and/or fluxes defined on this element
      Real * PNEWDT, // Recommended new timestep (unused)
      int JPROPS[],  // (NJPROP) NJPROP integer property values defined for the current element
      int * NJPROP,  // Number of user defined integer properties
      Real * PERIOD  // Current step time period (unused)
  );

  static InputParameters validParams();
  AbaqusUserElement(const InputParameters &amp; params);

  virtual void initialSetup() override;
  virtual void meshChanged() override;

  virtual void initialize() override final;
  virtual void execute() override;
  virtual void finalize() override final {}

  /// getters for the loop class
  const std::vector&lt;const MooseVariableFieldBase *&gt; &amp; getVariables() const { return _variables; }
  const std::vector&lt;const MooseVariableFieldBase *&gt; &amp; getAuxVariables() const
  {
    return _aux_variables;
  }

  const uel_t &amp; getPlugin() const { return _uel; }

protected:
  /// setup the range of elements this object operates on
  void setupElemRange();

  /// The plugin file name
  FileName _plugin;

  /// The plugin library wrapper
  DynamicLibraryLoader _library;

  /// Function pointer to the dynamically loaded function
  const uel_t _uel;

  /// The \p MooseMesh that this user object operates on
  MooseMesh &amp; _moose_mesh;

  /// The \p libMesh mesh that this object acts on
  const libMesh::MeshBase &amp; _mesh;

  /// The dimension of the mesh, e.g. 3 for hexes and tets, 2 for quads and tris
  const unsigned int _dim;

  /// coupled variables to provide the DOF values
  std::vector&lt;NonlinearVariableName&gt; _variable_names;

  /// Auxiliary variable names
  std::vector&lt;AuxVariableName&gt; _aux_variable_names;

  /// pointers to the variable objects
  std::vector&lt;const MooseVariableFieldBase *&gt; _variables;

  /// pointers to the auxiliary variable objects
  std::vector&lt;const MooseVariableFieldBase *&gt; _aux_variables;

  /// The subdomain ids this object operates on
  const std::set&lt;SubdomainID&gt; _sub_ids;

  /// All the active and elements local to this process that exist on this object&#x27;s subdomains
  std::unique_ptr&lt;ConstElemRange&gt; _elem_range;

  /// props
  std::vector&lt;Real&gt; _props;
  int _nprops;

  /// stateful data
  int _nstatev;
  std::array&lt;std::map&lt;dof_id_type, std::vector&lt;Real&gt;&gt;, 2&gt; _statev;
  std::size_t _statev_index_current;
  std::size_t _statev_index_old;

  /// Abaqus element type
  const int _jtype;

  friend class UELThread;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>